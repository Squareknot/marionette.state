{"version":3,"sources":["/source/marionette.state.js","marionette.state.min.js"],"names":["global","factory","exports","module","require","define","amd","Marionette","State","_","Backbone","Mn","this","callHandlers","target","entity","handlers","attr","value","get","undefined","isFunction","call","handlerKeys","split","spaceMatcher","each","handlerKey","syncBinding","event","changeMatch","Collection","Model","_state","match","changeMatcher","syncBindings","events","sync","bindings","eventStr","Syncing","_syncEntityEvents","bindEntityEvents","syncing","when","now","stopSyncingEntityEvents","unbindEntityEvents","__syncingEntityEvents","stopListening","eventObj","handler","prototype","_this","push","listenTo","Object","extend","modelClass","defaultState","componentEvents","_model","_component","_initialState","constructor","options","component","setComponent","initState","initialState","__super__","apply","arguments","attrs","reset","_proxyEvents","eventedObj","listenToOnce","destroy","getInitialState","clone","getComponent","getModel","set","Error","resetAttrs","getChanged","changedAttributes","getPrevious","previousAttributes","hasAnyChanged","_len","length","Array","_key","chain","changed","keys","intersection","size","syncEntityEvents","entityEvents","other","trigger","bind","StateBehavior","Behavior","initialize","stateClass","StateClass","syncEvent","stateOptions","view","_mapOptions","mapOptions","state","stateModel","stateEvents","serialize","_wrapSerializeData","mappings","object","map","_mapOption","viewOptionKey","stateOptionKey","stateOptionValue","isString","reduce","memo","key","_this2","serializeData","data","stateAttrs","attributes","isUndefined","isObject","_mergeAttrs","state_behavior","index"],"mappings":"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","file":"marionette.state.min.js","sourcesContent":["(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('underscore'), require('backbone'), require('backbone.marionette')) :\n  typeof define === 'function' && define.amd ? define(['underscore', 'backbone', 'backbone.marionette'], factory) :\n  global.Marionette.State = factory(global._, global.Backbone, global.Mn)\n}(this, function (_, Backbone, Mn) { 'use strict';\n\n  var changeMatcher = /^change:(.+)/;\n  var spaceMatcher = /\\s+/;\n\n  // Call all handlers optionally with a value (given a named attribute 'attr')\n  function callHandlers(target, entity, handlers, attr) {\n    var value = attr ? entity.get(attr) : undefined;\n\n    if (_.isFunction(handlers)) {\n      handlers.call(target, entity, value);\n    }\n    else {\n      var handlerKeys = handlers.split(spaceMatcher);\n      _.each(handlerKeys, (handlerKey) => {\n        target[handlerKey](entity, value);\n      });\n    }\n  }\n\n  // Sync 'target' with event 'event1' and its handlers 'handler1 handler2', depending on event\n  // and entity type.  Call value handlers for Backbone.Model 'change:attr' events, and call generic\n  // handlers for Backbone.Model 'change', 'all' or Backbone.Collection 'change', 'all', or 'reset'.\n  function syncBinding(target, entity, event, handlers) {\n    var changeMatch;\n    if (event === 'change' || event === 'all' ||\n        (entity instanceof Backbone.Collection && event === 'reset')) {\n      callHandlers(target, entity, handlers);\n    }\n    else if (\n        (entity instanceof Backbone.Model || entity instanceof _state) &&\n        (changeMatch = event.match(changeMatcher))) {\n      var attr = changeMatch[1];\n      callHandlers(target, entity, handlers, attr);\n    }\n  }\n\n  // Sync 'target' with an array of events ['event1', 'event2'] and their handlers\n  // 'handler1 handler2'.\n  function syncBindings(target, entity, events, handlers) {\n    _.each(events, (event) => {\n      syncBinding(target, entity, event, handlers);\n    });\n  }\n\n  // Sync 'target' with the bindings hash { 'event1 event 2': 'handler1 handler2' }.\n  function sync(target, entity, bindings) {\n    _.each(bindings, (handlers, eventStr) => {\n      var events = eventStr.split(spaceMatcher);\n      syncBindings(target, entity, events, handlers);\n    });\n  }\n\n  function Syncing(target, entity, bindings) {\n    this.target = target;\n    this.entity = entity;\n    this.bindings = bindings;\n  }\n\n  Syncing.prototype.when = function (eventObj, event) {\n    if (!event) {\n      event = eventObj;\n      eventObj = this.target;\n    }\n    this.eventObj = eventObj;\n    this.event = event;\n    this.handler = () => {\n      sync(this.target, this.entity, this.bindings);\n    };\n\n    this.target.__syncingEntityEvents = this.target.__syncingEntityEvents || [];\n    this.target.__syncingEntityEvents.push(this);\n    this.target.listenTo(this.eventObj, this.event, this.handler);\n    return this;\n  };\n\n  Syncing.prototype.now = function () {\n    sync(this.target, this.entity, this.bindings);\n    return this;\n  };\n\n  // Binds 'bindings' handlers located on 'target' to 'entity' using\n  // Marionette.bindEntityEvents, but then initializes state by calling handlers:\n  //   Backbone.Model\n  //     'all'          (model)\n  //     'change'       (model)\n  //     'change:value' (model, value)\n  //   Backbone.Collection\n  //     'all'          (collection)\n  //     'reset'        (collection)\n  //     'change'       (collection)\n  //\n  // Handlers are called immediately unless 'event' is supplied, in which case handlers will be\n  // called every time 'target' triggers 'event'. Views will automatically sync on 'render'\n  // unless this argument is supplied.\n  //\n  // For event mappings with multiple matching events, all handlers are called for each event.\n  // For example, the following mapping:\n  //   { 'change:foo change:bar': 'doSomething doSomethingElse' }\n  // will call:\n  //   doSomething(model, model.get('foo'))\n  //   doSomethingElse(model, model.get('foo'))\n  //   doSomething(model, model.get('bar'))\n  //   doSomethingElse(model, model.get('bar'))\n  function syncEntityEvents(target, entity, bindings, event) {\n    Mn.bindEntityEvents(target, entity, bindings);\n    var syncing = new Syncing(target, entity, bindings);\n    if (event) {\n      syncing.when(event);\n    }\n    else {\n      syncing.now();\n    }\n  }\n\n  // Ceases syncing entity events.\n  function stopSyncingEntityEvents(target, entity, bindings) {\n    Mn.unbindEntityEvents(target, entity, bindings);\n    if (target.__syncingEntityEvents) {\n      _.each(target.__syncingEntityEvents, (syncing) => {\n        target.stopListening(syncing.eventObj, syncing.event, syncing.handler);\n      });\n    }\n  }\n\n  const State = Mn.Object.extend({\n\n    // State model class to instantiate\n    modelClass: undefined,\n\n    // Default state attributes hash\n    defaultState: undefined,\n\n    // Events from my component\n    componentEvents: undefined,\n\n    // State model instance\n    _model: undefined,\n\n    // My component, facilitating lifecycle management and event bindings\n    _component: undefined,\n\n    // Initial state attributes hash after 'initialState' option and defaults are applied\n    _initialState: undefined,\n\n    // options {\n    //   component:    {Marionette object} An arbitrary object for lifetime and event binding.\n    //     May be any Marionette object, so long as it has a destroy() method.\n    //   initialState: {attrs} Optional initial state (defaultState will still be applied)\n    constructor(options) {\n      options = options || {};\n      // Bind to component\n      if (options.component) { this.setComponent(options.component); }\n\n      // State model class is either passed in, on the class, or a standard Backbone model\n      this.modelClass = options.modelClass || this.modelClass || Backbone.Model;\n\n      // Initialize state\n      this.initState(options.initialState);\n\n      State.__super__.constructor.apply(this, arguments);\n    },\n\n    // Initialize model with attrs or reset it, destructively, to conform to attrs.\n    initState(attrs, options) {\n      // Set initial state.\n      this._initialState = _.extend({}, this.defaultState, attrs);\n\n      if (this._model) {\n        // Reset existing model with initial state.\n        this.reset(null, options);\n      }\n      else {\n        // Create new model with initial state.\n        /* eslint-disable new-cap */\n        this._model = new this.modelClass(this._initialState);\n        this._proxyEvents(this._model);\n      }\n    },\n\n    // Bind lifetime and component events to an object initialized with Backbone.Events, such as\n    // a Backbone model or a Marionette object.\n    setComponent(eventedObj) {\n      this.stopListening(this._component, 'destroy');\n      if (this.componentEvents) {\n        this.unbindEntityEvents(this._component, this.componentEvents);\n      }\n      this._component = eventedObj;\n      this.listenToOnce(this._component, 'destroy', this.destroy);\n      if (this.componentEvents) {\n        this.bindEntityEvents(this._component, this.componentEvents);\n      }\n    },\n\n    // Returns the initiate state, which is reverted to by reset()\n    getInitialState() {\n      return _.clone(this._initialState);\n    },\n\n    // Marionette object bound to\n    getComponent() {\n      return this._component;\n    },\n\n    // Return the state model.\n    getModel() {\n      return this._model;\n    },\n\n    // Proxy to model set().\n    set() {\n      if (!this._model) { throw new Mn.Error('Initialize state first.'); }\n      this._model.set.apply(this._model, arguments);\n    },\n\n    // Proxy to model get().\n    get() {\n      if (!this._model) { throw new Mn.Error('Initialize state first.'); }\n      return this._model.get.apply(this._model, arguments);\n    },\n\n    // Return state to its initial value.\n    // If `attrs` is provided, they will override initial values for a \"partial\" reset.\n    reset(attrs, options) {\n      var resetAttrs = _.extend({}, this._initialState, attrs);\n      this._model.set(resetAttrs, options);\n    },\n\n    // Proxy to model changedAttributes().\n    getChanged() {\n      return this._model.changedAttributes();\n    },\n\n    // Proxy to model previousAttributes().\n    getPrevious() {\n      return this._model.previousAttributes();\n    },\n\n    // Determine if any of the passed attributes were changed during the last modification.\n    hasAnyChanged(...attrs) {\n      return !!_.chain(this._model.changed)\n        .keys()\n        .intersection(attrs)\n        .size()\n        .value();\n    },\n\n    // Proxy to StateFunctions#syncEntityEvents.\n    syncEntityEvents(entity, entityEvents, event) {\n      return syncEntityEvents(this, entity, entityEvents, event);\n    },\n\n    _proxyEvents: function (other) {\n      this.listenTo(other, 'all', function () {\n        if (arguments.length > 1 && arguments[1] === this._model) {\n          arguments[1] = this;\n        }\n        this.trigger.apply(this, arguments);\n      }.bind(this));\n    }\n  });\n\n  var _state = State;\n\n  const StateBehavior = Mn.Behavior.extend({\n\n    // options {\n    //   stateClass:   {Marionette.StateService class} Type of Marionette.State to instantiate\n    //   syncEvent:    {String} View event on which to call state handlers, keeping the DOM in\n    //                   sync with state. Defaults to 'render'.\n    //   initialState: {object} Optional initial state attrs\n    //   stateOptions: {object} Options to pass to Marionette.State\n    //   mapOptions:   {object} Map view options to Marionette.State options\n    //     - { stateOption: 'viewOption' }          viewOption will be passed as stateOption\n    //     - { stateOption: 'viewOption.property' } viewOption.property will be passed\n    //     - { stateOption: true }                  viewOption named 'stateOption' will be passed\n    //     - { stateOption: function(viewOptions) } return value of function will be passed\n    //   serialize:    {boolean} Whether to serialize state into template (default false)\n    // }\n    initialize(options) {\n      options = options || {};\n      if (!options.stateClass) { throw new Mn.Error('Must provide \\'stateClass\\'.'); }\n      var StateClass = options.stateClass;\n      var syncEvent = options.syncEvent || 'render';\n\n      // Compose State options and create State object\n      var stateOptions = _.extend({\n        initialState: options.initialState,\n        component:    this.view\n      }, options.stateOptions, this._mapOptions(options.mapOptions));\n      var state = new StateClass(stateOptions);\n\n      // Give view access to the state model, but not the state object directly in order to\n      // encourage decoupling; i.e., using view event triggers -> Marionette.State componentEvents.\n      if (this.view.stateModel) { throw new Error('View already contains a stateModel attribute.'); }\n      this.view.stateModel = state.getModel();\n\n      // Bind state events as well as call change handlers onRender to keep DOM in sync with state.\n      if (this.view.stateEvents) {\n        syncEntityEvents(this.view, this.view.stateModel, this.view.stateEvents, syncEvent);\n      }\n\n      // Optionally set up serialization of state attributes to view template as 'state.attribute'\n      if (options.serialize) { this._wrapSerializeData(); }\n    },\n\n    // Convert view options into Marionette.State options\n    _mapOptions(mappings) {\n      if (!mappings) {\n        return {};\n      }\n      return _.object(_.map(mappings, this._mapOption, this));\n    },\n\n    _mapOption(viewOptionKey, stateOptionKey) {\n      var stateOptionValue;\n\n      if (viewOptionKey === true) {\n        // Identity transformation; e.g., { stateOption: 'stateOption' }\n        stateOptionValue = this.view.options[stateOptionKey];\n      }\n      else if (_.isString(viewOptionKey)) {\n        // Unwind nested keys; e.g., 'value.property.subproperty'\n        stateOptionValue = _.reduce(viewOptionKey.split('.'), (memo, key) => {\n          return memo[key];\n        }, this.view.options);\n      }\n      else if (_.isFunction(viewOptionKey)) {\n        // Evaluate function in the view context and pass the view options\n        stateOptionValue = viewOptionKey.call(this.view, this.view.options);\n      }\n      else {\n        throw new Mn.Error('Invalid mapOption value. Expecting true, String, or Function.');\n      }\n\n      return [stateOptionKey, stateOptionValue];\n    },\n\n    // Safe wrapping of serialize data. Calls existing serializeData method then merges in state\n    // attributes.\n    _wrapSerializeData() {\n      var serializeData = this.view.serializeData;\n      var state = this.view.state;\n\n      this.view.serializeData = () => {\n        var data = serializeData.call(this); // 'this' is the view\n        var stateAttrs = _.clone(state.attributes);\n\n        // If existing attributes do NOT contain 'state', drop stateAttribute right in.\n        if (_.isUndefined(data.state)) {\n          data.state = stateAttrs;\n        }\n        // If existing attribute DO contain 'state', attempt a safe merge.\n        else if (_.isObject(data.state)) {\n          this._mergeAttrs(data.state, stateAttrs);\n        }\n        else {\n          throw new Mn.Error('\\'state\\' already defined and not extensible.');\n        }\n\n        return data;\n      };\n    },\n\n    // Assign attributes into target, throwing Error rather than overwriting any existing.\n    _mergeAttrs(target, attrs) {\n      for (var attr in attrs) {\n        if (_.isUndefined(target[attr])) {\n          target[attr] = attrs[attr];\n        }\n        else {\n          throw new Mn.Error('Attribute \\'' + attr + '\\' already defined.');\n        }\n      }\n    }\n  });\n\n  var state_behavior = StateBehavior;\n\n  _state.Behavior = state_behavior;\n  _state.syncEntityEvents = syncEntityEvents;\n  _state.stopSyncingEntityEvents = stopSyncingEntityEvents;\n\n  var index = _state;\n\n  return index;\n\n}));\n",null],"sourceRoot":"/source/"}