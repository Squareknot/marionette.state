{"version":3,"sources":["marionette.state.min.js","/source/marionette.state.js"],"names":["_classCallCheck","instance","Constructor","TypeError","_createClass","defineProperties","target","props","i","length","descriptor","enumerable","configurable","writable","Object","defineProperty","key","protoProps","staticProps","prototype","global","factory","exports","module","require","define","amd","Marionette","State","_","Bb","Mn","this","syncBinding","entity","event","handlers","modelEventMatch","changeOpts","syncing","collectionMatch","Collection","match","collectionEventMatcher","modelMatch","Model","state","modelEventMatcher","changeAttr","changeArgs","push","get","isFunction","apply","handlerKeys","split","spaceMatcher","handlerKey","sync","bindings","Error","eventStr","events","syncEntityEvents","Syncing","_when","_now","hasAnyChanged","model","_model","_len2","arguments","attrs","Array","_key2","chain","changed","keys","intersection","size","value","extend","modelClass","undefined","defaultState","componentEvents","_component","_initialState","constructor","_ref","initialState","component","preventDestroy","_initState","bindComponent","__super__","_proxyModelEvents","getModel","getInitialState","clone","attr","set","val","options","reset","resetAttrs","attributes","changedAttributes","previous","previousAttributes","_len","_key","concat","_ref2","bindEntityEvents","listenTo","destroy","unbindComponent","unbindEntityEvents","stopListening","entityEvents","other","trigger","state_functions","off","handler","bind","on","stop","index"],"mappings":"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","file":"marionette.state.min.js","sourcesContent":[null,"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('underscore'), require('backbone'), require('backbone.marionette')) :\n  typeof define === 'function' && define.amd ? define(['underscore', 'backbone', 'backbone.marionette'], factory) :\n  global.Marionette.State = factory(global._, global.Bb, global.Mn)\n}(this, function (_, Bb, Mn) { 'use strict';\n\n  const State = Mn.Object.extend({\n\n    // State model class to instantiate\n    modelClass: undefined,\n\n    // Default state attributes hash\n    defaultState: undefined,\n\n    // Events from my component\n    componentEvents: undefined,\n\n    // State model instance\n    _model: undefined,\n\n    // My component, facilitating lifecycle management and event bindings\n    _component: undefined,\n\n    // Initial state attributes hash after 'initialState' option and defaults are applied\n    _initialState: undefined,\n\n    // options {\n    //   initialState: {object} Attributes that will override `defaultState`.  The result of\n    //     defaultState + initialState is the state reverted to by `#reset`.\n    //   component: {Mn object} Object to which to bind `componentEvents` and also lifecycle;\n    //     i.e., when `component` fires 'destroy', then destroy myself.\n    //   preventDestroy: {boolean} If true, then this will not destroy on `component` destroy.\n    // }\n    constructor({ initialState, component, preventDestroy }={}) {\n      // State model class is either passed in, on the class, or a standard Backbone model\n      this.modelClass = this.modelClass || Bb.Model;\n\n      // Initialize state\n      this._initState(initialState);\n\n      if (component) {\n        this.bindComponent(component, { preventDestroy });\n      }\n\n      State.__super__.constructor.apply(this, arguments);\n    },\n\n    // Initialize model with attrs or reset it, destructively, to conform to attrs.\n    _initState(attrs) {\n      // Set initial state.\n      this._initialState = _.extend({}, this.defaultState, attrs);\n\n      // Create new model with initial state.\n      /* eslint-disable new-cap */\n      this._model = new this.modelClass(this._initialState);\n      this._proxyModelEvents(this._model);\n    },\n\n    // Return the state model.\n    getModel() {\n      return this._model;\n    },\n\n    // Returns the initiate state, which is reverted to by reset()\n    getInitialState() {\n      return _.clone(this._initialState);\n    },\n\n    // Proxy to model get().\n    get(attr) {\n      return this._model.get(attr);\n    },\n\n    // Proxy to model set().\n    set(key, val, options) {\n      this._model.set(key, val, options);\n      return this;\n    },\n\n    // Return state to its initial value.\n    // If `attrs` is provided, they will override initial values for a \"partial\" reset.\n    // Initial state will remain unchanged regardless of override attributes.\n    reset(attrs, options) {\n      var resetAttrs = _.extend({}, this._initialState, attrs);\n      this._model.set(resetAttrs, options);\n      return this;\n    },\n\n    attributes() {\n      return _.clone(this._model.attributes);\n    },\n\n    // Proxy to model changedAttributes().\n    changedAttributes() {\n      return this._model.changedAttributes();\n    },\n\n    // Proxy to model previous().\n    previous(attr) {\n      return this._model.previous(attr);\n    },\n\n    // Proxy to model previousAttributes().\n    previousAttributes() {\n      return this._model.previousAttributes();\n    },\n\n    // Whether any of the passed attributes were changed during the last modification\n    hasAnyChanged(...attrs) {\n      return State.hasAnyChanged(this, ...attrs);\n    },\n\n    // Bind `componentEvents` to `component` and cascade destroy to self when component fires\n    // 'destroy'.  To prevent self-destroy behavior, pass `preventDestroy: true` as an option.\n    bindComponent(component, { preventDestroy }={}) {\n      this.bindEntityEvents(component, this.componentEvents);\n      if (!preventDestroy) {\n        this.listenTo(component, 'destroy', this.destroy);\n      }\n    },\n\n    // Unbind `componentEvents` from `component` and stop listening to component 'destroy' event.\n    unbindComponent(component) {\n      this.unbindEntityEvents(component, this.componentEvents);\n      this.stopListening(component, 'destroy', this.destroy);\n    },\n\n    // Proxy to StateFunctions#syncEntityEvents.\n    syncEntityEvents(entity, entityEvents, event) {\n      State.syncEntityEvents(this, entity, entityEvents, event);\n      return this;\n    },\n\n    // Convert model events to state events\n    _proxyModelEvents(other) {\n      this.listenTo(other, 'all', function () {\n        if (arguments.length > 1 && arguments[1] === this._model) {\n          // Replace model argument with State\n          arguments[1] = this;\n        }\n        this.trigger.apply(this, arguments);\n      });\n    }\n  });\n\n  var state = State;\n\n  var state_functions = {\n    get sync () { return sync; },\n    get syncEntityEvents () { return syncEntityEvents; },\n    get hasAnyChanged () { return hasAnyChanged; }\n  };\n\n  const modelEventMatcher = /^(?:all|change|change:(.+))$/;\n  const collectionEventMatcher = /^(?:all|reset)$/;\n  const spaceMatcher = /\\s+/;\n\n  // Sync individual event binding 'event1' => 'handler1 handler2'.\n  function syncBinding(target, entity, event, handlers) {\n    var changeOpts = { syncing: true };\n    var modelEventMatch;\n\n    // Only certain model/collection events are syncable.\n    var collectionMatch =\n        entity instanceof Bb.Collection &&\n        event.match(collectionEventMatcher);\n    var modelMatch =\n        (entity instanceof Bb.Model || entity instanceof state) &&\n        (modelEventMatch = event.match(modelEventMatcher));\n    if (!collectionMatch && !modelMatch) { return; }\n\n    // Collect change event arguments.\n    var changeArgs = [entity];\n    var changeAttr;\n    if (modelEventMatch && (changeAttr = modelEventMatch[1])) {\n      changeArgs.push(entity.get(changeAttr));\n    }\n    changeArgs.push(changeOpts);\n\n    // Call change event handler.\n    if (_.isFunction(handlers)) {\n      handlers.apply(target, changeArgs);\n    } else {\n      var handlerKeys = handlers.split(spaceMatcher);\n      for (var i = 0; i < handlerKeys.length; i++) {\n        var handlerKey = handlerKeys[i];\n        target[handlerKey].apply(target, changeArgs);\n      }\n    }\n  }\n\n  // Sync bindings hash { 'event1 event 2': 'handler1 handler2' }.\n  function sync(target, entity, bindings) {\n    if (!entity) { throw new Mn.Error('`entity` must be provided.'); }\n    if (!bindings) { throw new Mn.Error('`bindings` must be provided.'); }\n    for (var eventStr in bindings) {\n      var handlers = bindings[eventStr];\n      var events = eventStr.split(spaceMatcher);\n      for (var i = 0; i < events.length; i++) {\n        var event = events[i];\n        syncBinding(target, entity, event, handlers);\n      }\n    }\n  }\n\n  // A stoppable handle on the syncing listener\n  class Syncing {\n\n    constructor(target, entity, bindings) {\n      this.target = target;\n      this.entity = entity;\n      this.bindings = bindings;\n    }\n\n    stop() {\n      Mn.unbindEntityEvents(this.target, this.entity, this.bindings);\n      this.target.off(this.event, this.handler);\n      this.event = this.handler = null;\n    }\n\n    _when(event) {\n      Mn.bindEntityEvents(this.target, this.entity, this.bindings);\n      this.event = event;\n      this.handler = _.bind(sync, this, this.target, this.entity, this.bindings);\n      this.target\n        .on(this.event, this.handler)\n        .on('destroy', _.bind(this.stop, this));\n    }\n\n    _now() {\n      Mn.bindEntityEvents(this.target, this.entity, this.bindings);\n      sync(this.target, this.entity, this.bindings);\n    }\n  }\n\n  // Binds events handlers located on target to an entity using Marionette.bindEntityEvents, and\n  // also \"syncs\" initial state either immediately or whenever target fires a specific event.\n  //\n  // Initial state is synced by calling certain handlers at a precise moment.  Only the following\n  // entity events will sync their handlers: 'all', 'change', 'change:attr', and 'reset'.\n  //\n  // Returns a Syncing instance.  While syncing handlers are unbound on target destroy, the syncing\n  // instance has a single public method stop() for ceasing syncing on target events early.\n  function syncEntityEvents(target, entity, bindings, event) {\n    var syncing = new Syncing(target, entity, bindings);\n    if (event) {\n      syncing._when(event);\n    } else {\n      syncing._now();\n    }\n    return syncing;\n  }\n\n  // Determine if any of the passed attributes were changed during the last modification of `model`.\n  function hasAnyChanged(model, ...attrs) {\n    // Support Marionette.State or Backbone.Model performantly.\n    if (model._model) { model = model._model; }\n    return !!_.chain(model.changed)\n      .keys()\n      .intersection(attrs)\n      .size()\n      .value();\n  }\n\n  _.extend(state, state_functions);\n\n  var index = state;\n\n  return index;\n\n}));\n"],"sourceRoot":"/source/"}